import util.
import math.

% 1. This one runs if you type: picat wordle.pi
main => 
    run_game(false).

% 2. This one runs if you type: picat wordle.pi --use-played
main(Args) =>
    UsePlayed = cond(membchk("use-played", Args), true, false),
    run_game(UsePlayed).

% 3. The actual logic moved to a separate predicate
run_game(UsePlayed) =>
    % 1. Load the dictionary
    AllWords = [W : W in read_file_lines("words.txt"), length(W) == 5],
    
    if UsePlayed then
        PlayedWords = read_file_lines("played.txt"),
        FinalCandidates = [W : W in AllWords, not membchk(W, PlayedWords)],
        printf("Excluded played words. Candidates left: %d\n", length(FinalCandidates))
    else
        FinalCandidates = AllWords,
        printf("Running in standard mode. Candidates: %d\n", length(AllWords))
    end,
    
    % The solver starts with a strong opener
    solve_loop(FinalCandidates, AllWords, "tares").

% The interaction loop
solve_loop(Candidates, FullDictionary, CurrentGuess) =>
    Count = length(Candidates),
    printf("\n--- New Turn ---\n"),
    printf("Remaining candidates: %d\n", Count),
    
    if (Count == 1) then
        printf("The word is: %w\n", Candidates[1]),
        halt
    elseif (Count <= 10) then
        printf("Possible words: %w\n", Candidates)
    end,

    % Convert current guess to uppercase for display
    UGuess = [to_uppercase(C) : C in CurrentGuess],
    printf("My guess is: %s\n", UGuess),
    
    printf("Enter feedback (G=Green, Y=Yellow, .=Gray): "),
    Feedback = read_line().strip(),
    
    % Translate feedback (G, Y, .) to numeric pattern (2, 1, 0)
    Pattern = [cond(C == 'G', 2, cond(C == 'Y', 1, 0)) : C in Feedback],
    
    % Prune the list based on the guess just made
    NewCandidates = [W : W in Candidates, get_feedback(CurrentGuess, W) == Pattern],
    
    if (NewCandidates == []) then
        printf("Error: No words match that feedback!\n"),
        halt
    end,

    % Find the NEXT guess
    NextGuess = pick_best_guess(NewCandidates, FullDictionary),
    solve_loop(NewCandidates, FullDictionary, NextGuess).

% --- LOGIC: Select the best word to play next ---
pick_best_guess(Candidates, FullDict) = BestWord =>
    Len = length(Candidates),
    if (Len == 1) then
        BestWord = Candidates[1]
    elseif (Len == 2) then
        printf("Two candidates left. Guessing one for a 50/50 win chance...\n"),
        BestWord = Candidates[1]
    else
        printf("Calculating best entropy for next move... "),
        Scored = [(calculate_entropy(W, Candidates), W) : W in FullDict],
        Sorted = sort_down(Scored),
        
        BestPair = Sorted[1],
        (MaxScore, Selection) = BestPair,
        BestWord = Selection,
        
        printf("Done (Best: %s at %.2f bits)\n", BestWord, MaxScore)
    end.

% --- LOGIC: Feedback Simulator ---
get_feedback(Guess, Target) = Pattern =>
    Pattern = new_list(5),
    Counts = new_map(),
    foreach(C in Target) Counts.put(C, Counts.get(C, 0) + 1) end,

    foreach(I in 1..5)
        if Guess[I] == Target[I] then
            Pattern[I] = 2,
            Counts.put(Guess[I], Counts.get(Guess[I]) - 1)
        end
    end,

    foreach(I in 1..5)
        if var(Pattern[I]) then
            Char = Guess[I],
            if Counts.get(Char, 0) > 0 then
                Pattern[I] = 1,
                Counts.put(Char, Counts.get(Char) - 1)
            else
                Pattern[I] = 0
            end
        end
    end.

% --- LOGIC: Entropy Calculation ---
calculate_entropy(Guess, Candidates) = Entropy =>
    Total = length(Candidates),
    Buckets = new_map(),
    foreach(C in Candidates)
        P = get_feedback(Guess, C),
        Buckets.put(P, Buckets.get(P, 0) + 1)
    end,
    Ent = 0.0,
    foreach(Pattern in keys(Buckets))
        Count = Buckets.get(Pattern),
        Prob = Count / Total,
        Ent := Ent - (Prob * log2(Prob))
    end,
    Entropy = Ent.